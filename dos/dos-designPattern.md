
### Algorithms

- Sequential
  - Linear Search
  - Binary Search
  - Bubble Sort
  - Insertion Sort
  - Selection Sort
- Divide and Conquer
  - Merge Sort
  - Quick Sort
- Greedy
  - Dijkstra's Algorithm
  - Kruskal's Algorithm
  - Huffman Coding
- Dynamic Programming
  - Fibonacci Sequence
  - Longest Common Subsequence
  - Knapsack Problem
- Backtracking
  - N-Queens Problem
  - Sudoku Solver
- Randomized
  - Quick Select
  - Randomized Quicksort
- Branch and Bound
  - Traveling Salesman Problem
  - 0/1 Knapsack Problem
- Heuristics
  - Simulated Annealing
  - Genetic Algorithms
- Approximation
  - Approximation Algorithms
  - Polynomial-Time Approximation Scheme (PTAS)

```
In this mind map, we have several categories of algorithms, each with several examples listed as bullet points. Here are brief descriptions of each category and example:
Sequential: Algorithms that iterate through a list of items one by one.
Linear Search: Searches for a specific value in a list by iterating through each item.
Binary Search: Searches for a specific value in a sorted list by dividing the list in half repeatedly.
Bubble Sort: Sorts a list by repeatedly swapping adjacent items if they are in the wrong order.
Insertion Sort: Sorts a list by repeatedly inserting each item into its correct position in a sorted sublist.
Selection Sort: Sorts a list by repeatedly selecting the smallest unsorted item and swapping it with the first unsorted item.
Divide and Conquer: Algorithms that divide a problem into smaller subproblems and solve them recursively.
Merge Sort: Sorts a list by dividing it in half repeatedly, sorting each half, and merging the sorted halves.
Quick Sort: Sorts a list by selecting a pivot item, partitioning the list around the pivot, and recursively sorting the partitions.
Greedy: Algorithms that make locally optimal choices at each step in the hope of finding a global optimum.
Dijkstra's Algorithm: Finds the shortest path between two nodes in a graph with non-negative edge weights.
Kruskal's Algorithm: Finds a minimum spanning tree for a connected, weighted graph.
Huffman Coding: Generates a variable-length prefix code for a set of characters based on their frequencies.
Dynamic Programming: Algorithms that solve a problem by breaking it down into smaller subproblems and storing the solutions to those subproblems.
Fibonacci Sequence: Generates the nth number in the Fibonacci sequence.
Longest Common Subsequence: Finds the longest subsequence that is common to two sequences.
Knapsack Problem: Finds the most valuable combination of items that can be put into a knapsack of limited capacity.
Backtracking: Algorithms that solve a problem by trying out different solutions and undoing them if they don't work.
N-Queens Problem: Finds all possible ways to place n queens on an n x n chessboard without any of them attacking each other.
Sudoku Solver: Solves a Sudoku puzzle by trying out different numbers and undoing them if they lead to an invalid solution.
Randomized: Algorithms that use randomness to improve their performance or guarantee their correctness.
Quick Select: Finds the kth smallest item in an unsorted list by selecting a random pivot and partitioning the list around it.
Randomized Quicksort: Sorts a list by selecting a random pivot and partitioning the list around it.
Branch and Bound: Algorithms that solve a problem by exploring a tree of possible solutions and pruning branches that cannot lead to a better solution.
Traveling Salesman Problem: Finds the shortest possible route that visits every city in a set exactly once.
0/1 Knapsack Problem: Finds the most valuable combination of items that can be put into a knapsack of limited capacity, where each item can only be used once.
Heuristics: Algorithms that use a rule of thumb or approximation to find a solution that is good enough.
Simulated Annealing: Finds a good solution to an optimization problem by simulating the annealing process in metallurgy.
Genetic Algorithms: Finds a good solution to an optimization problem by simulating the process of natural selection.
Approximation: Algorithms that find a solution that is close to the optimal solution, but not necessarily the optimal solution.
Approximation Algorithms: Finds a solution that is guaranteed to be within a certain factor of the optimal solution.
Polynomial-Time Approximation Scheme (PTAS): Finds a solution that is guaranteed to be within a certain factor of the optimal solution, where the factor depends on the input size.

```


