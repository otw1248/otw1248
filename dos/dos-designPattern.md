
### Design Patterns

- Creational
  - Singleton
  - Factory Method
  - Builder
  - Prototype
- Structural
  - Adapter
  - Bridge
  - Composite
  - Decorator
  - Facade
  - Flyweight
  - Proxy
- Behavioral
  - Observer
  - Strategy
  - Command
  - Chain of Responsibility
  - Interpreter
  - Iterator
  - Mediator
  - Memento
  - State
  - Template Method
  - Visitor

```
In this mind map, we have three main categories of design patterns: Creational, Structural, and Behavioral. Creational patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. Structural patterns deal with object composition, trying to form large structures from individual objects. Behavioral patterns deal with communication between objects, trying to define how objects interact and distribute responsibility.
Under each category, we have several design patterns. Here are brief descriptions of each pattern:
Creational Patterns:
Singleton: Ensures that a class has only one instance and provides a global point of access to it.
Factory Method: Defines an interface for creating objects, but lets subclasses decide which classes to instantiate.
Builder: Separates the construction of a complex object from its representation, allowing the same construction process to create various representations.
Prototype: Creates new objects by cloning an existing object.
Structural Patterns:
Adapter: Converts the interface of a class into another interface that clients expect.
Bridge: Separates an object's interface from its implementation, allowing them to vary independently.
Composite: Composes objects into tree structures to represent part-whole hierarchies.
Decorator: Dynamically adds responsibilities to an object.
Facade: Provides a unified interface to a set of interfaces in a subsystem.
Flyweight: Uses sharing to support large numbers of fine-grained objects efficiently.
Proxy: Provides a surrogate or placeholder for another object to control access to it.
Behavioral Patterns:
Observer: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
Strategy: Defines a family of algorithms, encapsulates each one, and makes them interchangeable.
Command: Encapsulates a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.
Chain of Responsibility: Avoids coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.
Interpreter: Given a language, defines a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.
Iterator: Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
Mediator: Defines an object that encapsulates how a set of objects interact, promoting loose coupling by keeping objects from referring to each other explicitly.
Memento: Without violating encapsulation, captures and externalizes an object's internal state so that the object can be restored to this state later.
State: Allows an object to alter its behavior when its internal state changes.
Template Method: Defines the skeleton of an algorithm in a method, deferring some steps to subclasses.
Visitor: Defines a new operation to a class without changing the class itself.

```
